# Smart Logistics & Delivery Optimization: Graph Routing Design

This document describes the design and implementation of the graph-based routing engine, a fundamental component for calculating optimal paths in the Smart Logistics & Delivery Optimization system. The system relies on OpenStreetMap (OSM) data and integrates both external routing services and custom algorithms.

## Road Network Representation

1.  **Source Data:** OpenStreetMap (OSM) provides the raw geospatial data for roads, nodes, and associated attributes (e.g., speed limits, road types, one-way streets).
2.  **Graph Construction (OSMnx):**
    *   OSMnx is used to download and parse OSM data for specific geographic regions (e.g., Tehran).
    *   The data is transformed into a `networkx` MultiDiGraph, representing the road network as a collection of nodes (intersections) and directed edges (road segments).
    *   Key attributes like `length` (meters) and `maxspeed` (kph) are extracted and assigned to edges. `travel_time` (seconds) is calculated for each edge based on length and speed.
    *   The graph is cleaned by removing isolated components and simplifying complex geometries.
    *   The preprocessed graph is serialized (e.g., to GraphML) for efficient loading and reuse.

## Dynamic Edge Weight Calculation

Traditional routing often uses static edge weights (e.g., fixed travel time). For smart logistics, dynamic weights are crucial:

1.  **Base Travel Time:** Calculated from `length` and `maxspeed` on each edge.
2.  **Real-time Traffic Factor:**
    *   Data from Kafka streams (e.g., vehicle telemetry, external traffic APIs) is used to estimate current traffic conditions.
    *   A `traffic_factor` (e.g., 1.0 for normal, 2.0 for heavy congestion) is applied to the base travel time of specific road segments. This factor can be dynamically updated in Redis.
3.  **Graph Neural Networks (GNNs):**
    *   A GNN model is trained to predict `traffic_factor` or directly predict `current_travel_time` for edges based on historical traffic patterns, time of day, weather, and real-time sensor data.
    *   The GNN considers spatial dependencies (how traffic propagates through the network) and temporal dependencies.
    *   GNN embeddings can also represent node/edge features for RL agents.

## Routing Algorithms

The system employs a multi-faceted approach to routing:

1.  **External Routing Engines (Valhalla/GraphHopper):**
    *   For standard, production-grade routing, we integrate with established services like Valhalla or GraphHopper.
    *   These engines offer advanced features like turn-by-turn instructions, elevation profiles, and support for various vehicle profiles.
    *   They can be self-hosted for performance and data privacy.
    *   API clients are developed to interact with these services, passing origin/destination nodes and dynamic parameters (e.g., `avoid_segment`, `preferred_speed`).

2.  **Custom A* Optimization Logic:**
    *   A custom A\* search algorithm is implemented for scenarios requiring highly specialized cost functions or constraints not easily expressible in external engines.
    *   **Heuristic Function:** Straight-line distance (Haversine) or precomputed shortest path estimates.
    *   **Cost Function:**
        *   `g(n)`: Accumulated cost from start to current node `n`. Includes dynamic travel time (incorporating traffic and GNN predictions), fuel cost, and potentially driver-specific costs.
        *   `h(n)`: Estimated cost from current node `n` to target.
    *   **Constraints:** Time windows for pickups/deliveries, vehicle capacity, driver breaks.
    *   **Multi-Objective Optimization:** The A\* algorithm can be extended to handle multiple objectives, e.g., minimize time *and* fuel, using techniques like Pareto optimality.

## Integration with Reinforcement Learning

*   **Action Space:** RL agents can choose high-level routes or request fine-grained segment decisions from the routing engine.
*   **State Features:** Graph embeddings generated by the GNN (representing network characteristics and dynamic conditions) serve as critical features for the RL agent's observation space.
*   **Dynamic Re-routing:** The RL agent can trigger the routing engine to recalculate paths in real-time based on new information (e.g., a traffic jam, a cancelled order).

## Key Design Principles

*   **Modularity:** Decoupling graph processing, dynamic weighting, and routing algorithms.
*   **Performance:** Utilizing efficient graph data structures, caching, and external services for speed.
*   **Flexibility:** Easily adaptable to new road networks, traffic data sources, and optimization objectives.
*   **Scalability:** Designed to handle large road networks and high query volumes.
